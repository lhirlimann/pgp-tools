#!/usr/bin/perl -w
#
# gpg-key2ps: convert a PGP/GnuPG key into paper slips.
# Copyright (C) 2001-2005  Simon Richter and Thijs Kinkhorst
# Licenced under the GNU General Public License,
# version 2 or later.
#
# $Id$

use strict;
use Getopt::Std;

my $version = '$Rev$';
$version =~ s/\$Rev:\s*(\d+)\s*\$/$1/;
my $usage = "Usage: $0 [-p papersize] [-r revoked-style] keyid-or-name\n";
my $keyids = "";
my $revokestyle="hide";

if ( $#ARGV < 0 ) {
	print $usage;
	exit 1;
}

# fetch command line parameters
my %opts;
getopt('pr', \%opts);
if ( $opts{r} ) { $revokestyle = $opts{'r'}; }
if ( $opts{p} ) { $ENV{'PAPERSIZE'} = $opts{'p'}; }
foreach (@ARGV) { $keyids .= $_ . " "; }

if ( $revokestyle !~ /^(grey|hide|note|show|strike)$/ ) {
	print STDERR "Unknown style \"$revokestyle\". Please use one of\n";
	print STDERR "  grey   - Print text in grey\n";
	print STDERR "  hide   - Don't show revoked uids\n";
	print STDERR "  note   - Add \"(revoked)\"\n";
	print STDERR "  show   - List revoked uids normally\n";
	print STDERR "  strike - Strike through lines\n";
	exit 1;
}

# determine default papersize through the paperconf tool
my $w; my $h;
if ( -x "/usr/bin/paperconf" ) {
	$w=`paperconf -w`;
	$h=`paperconf -h`;
	chomp($w);
	chomp($h);
} else {
	# Default to A4.
	$w=596;
	$h=842;
}

# check if key exists
# can't check that accurately through the 'open' call below
# so have to run gpg twice). Please supply a better way.
if ( system( "gpg --fingerprint $keyids >/dev/null" ) != 0 ) {
	print STDERR "Key not found. Try 'gpg --list-keys'\n";
	exit 1;
}

# open a gpg process we'll be reading from below
open(GPG, "gpg --fingerprint --with-colons $keyids |");

# start the PostScript output
print <<EOF;
%!PS-Adobe-3.0
%%BoundingBox: 0 0 $w $h
%%Title: 
%%Creator: gpg-key2ps $version
EOF
print "%%CreationDate: " . scalar(localtime) . "\n";
print <<EOF;
%%Pages: 1
%%EndComments

%%Page: 1 1

/w $w def
/h $h def

/Times-Roman findfont 9 scalefont setfont 

/newline {
	/y y 10 sub def
} def

/hline {
	30 y 3 add moveto
	w 2 div 30 sub y 3 add lineto stroke
	newline
} def

/needhline {
	/condhline { hline } def
} def

/noneedhline {
	/condhline { } def
} def

/showAlgorithm {
  << 1 (R) 2 (r) 3 (s) 16 (g) 20 (G) 17 (D) >> exch get
  show
} def

/pub {
	condhline
	50 y moveto (pub) show
	70 y moveto show showAlgorithm (/) show show
	150 y moveto show
	200 y moveto show
	newline
	needhline
} def

/fpr {
	70 y moveto (Key fingerprint = ) show show
	newline
} def

/uid {
	50 y moveto (uid) show
	200 y moveto show
	newline
} def

EOF

# output the desired display for revoked uids
if ( $revokestyle eq "grey" ) {
	print "/revuid {\n";
	print "	.5 setgray\n";
	print "	uid\n";
	print "	0 setgray\n";
	print "} def\n";
} elsif ( $revokestyle eq "hide" ) {
	print "/revuid {} def\n";
} elsif ( $revokestyle eq "note" ) {
	print "/revuid {\n";
	print "	50 y moveto (uid) show\n";
	print "	200 y moveto show ([revoked]) show\n";
	print "	newline\n";
	print "} def\n";
} elsif ( $revokestyle eq "show" ) {
	print "/revuid { uid } def\n";
} elsif ( $revokestyle eq "strike" ) {
	print "/revuid {\n";
	print "	uid\n";
	print "	45 y 9 add moveto h 2 div 45 sub y 18 add lineto stroke\n";
	print "} def\n";
}

print <<EOF;

/sbk {
	50 y moveto (sub) show
	70 y moveto show showAlgorithm (/) show show
	150 y moveto show
	newline
} def

/key {
	noneedhline
EOF

# walk the output of gpg line by line
# $numlines has the total number of lines so we'll know how many to put on page
my $numlines = 0;
while(<GPG>) {
	# we don't use these
	if ( /^(tru|uat):/ ) { next; }
	# every primary uid causes an extra line because of the separator
	if ( /^pub:/ ) { $numlines++; } 
	# primary uid
	s/^pub:[^:]*:([^:]*):([0-9]*):.{8,8}(.{8,8}):([^:]*):[^:]*:[^:]*:[^:]*:([^:]*):[^:]*:[^:]*:.*/	($5) ($4) ($3) $2 ($1) pub/;
	# fingerprint, format it nicely with spaces
	if ( /^fpr:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:([^:]*):.*/ ) {
		my $fpr = $1;
		# v4 key
		$fpr =~ s/(\w{4})(\w{4})(\w{4})(\w{4})(\w{4})(\w{4})(\w{4})(\w{4})(\w{4})(\w{4})/$1 $2 $3 $4 $5  $6 $7 $8 $9 $10/;
		# v3 key
		$fpr =~ s/(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})/$1 $2 $3 $4 $5 $6 $7 $8  $9 $10 $11 $12 $13 $14 $15 $16/g;
		$_ = "	($fpr) fpr\n";
	}
	# user id's
	s/^uid:[^:r]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:([^:]*):.*/	($1) uid/;
	s/^uid:[^:r]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:([^:]*):.*/	($1) uid/;
	# revoked user id
	s/^uid:r[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:([^:]*):.*/	($1) revuid/;
	# subkey
	s/^sub:[^:]*:([^:]*):([0-9]*):.{8,8}(.{8,8}):([^:]*):[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:.*/	($4) ($3) $2 ($1) sbk/;
	$numlines++;
	# print this line
	print;
}
close(GPG);

# output the remaining postscript
print <<EOF;
} def

EOF
print "/numlines $numlines def\n";
print <<EOF;
/num w 16 sub 10 div numlines div def

/column {
	/y w 20 sub def
	1 1 num {
		gsave
		0 0 h 2 div w rectclip
		/upper y 11 add def
		key
		newline
		/lower y 11 add def
		0 upper h 2 div upper h 2 div lower 0 lower 0 upper moveto lineto lineto lineto lineto stroke
		grestore
	} for
} def

w 0 translate
90 rotate
column
h 2 div 0 translate
column

showpage

%%Trailer
%%EOF
EOF

# done!
exit 0;


__END__

=head1 NAME

B<gpg-key2ps> - generates a PS file from a GnuPG keyring

=head1 SYNOPSIS

B<gpg-key2ps> [-r I<revoked-style>] [-p I<papersize>] I<keyid>I<[> I<keyidI<[> I<...>I<]>>I<]>

=head1 DESCRIPTION

gpg-key2ps generates a PostScript file with your OpenPGP key fingerprint (repeated
as often as it fits) useful for keysigning parties. The only argument is the same
as you would pass to GPG's list-keys command, either a key-id or a (partial) name.
The PS data is written to stdout.

=head1 OPTIONS

=over

=item -p I<paper-size>

Select the output paper size. Default is to look into /etc/papersize or A4 if
libpaper isn't installed.

=item -r I<revoked-style>

Select how to mark revoked UIDs. Five styles are available:
B<hide> (don't show at all),
B<show> (show normally),
B<grey> (display in 50% grey),
B<note> (add a note), and
B<strike> (strike through).

=item I<keyid>

Keyid's to print. Multiple can be separated by spaces.


=back


=head1 SEE ALSO

gpg(1)

http://pgp-tools.alioth.debian.org/

=head1 AUTHORS AND COPYRIGHT

(c) 2001 - 2005 Simon Richter <sjr@debian.org>

(c) 2005 Thijs Kinkhorst <thijs@kinkhorst.com>

